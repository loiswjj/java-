1. JMM
JMM（Java Memory Model）：是一种规范，定义了程序中各个变量，包括实例字段、静态字段以及构成数组对象的元素的访问方式
JMM关于同步的规定：
a) 线程解锁前，必须共享变量的值刷新回主内存（可见性）
b) 线程加锁前，必须读取主内存的最新值刷新回自己的工作内存
c) 加锁与解锁必须是一把锁

2. volatile关键字
一种轻量级的同步机制，具有三大特性，保证可见性、不保证原子性、可以防止指令重排序
手写单例模式 利用synchronized 双重验证
public class Singleton {
    private static volatile Singleton s;
    private Singleton(){};
    public static Singleton getInstance() {
        if(s == null) {
            synchronized (Singleton.class) {
                if(s == null) {
                    s = new Singleton();
                }
            }
        }
        return s;
    }
}

3. java的重量级锁、轻量级锁、自旋锁、偏向锁
重量级锁指得就是只要一个变量是共享数据，就直接给这个变量加锁（一直加锁），线程在访问时必须先获得锁，如果
没有获得锁该线程会被挂起；java1.5之前的Sychorized
由于Sychorized锁的性能低下，java1.5之后对其进行了大量优化

自旋锁：经实践证明在应用过程中，共享数据的锁定状态其实只会持续很短的一段时间，因为为了这样很短的时间，去
挂起和恢复线程不值得，代价太大，这是可以选择让这个线程首先进行自旋操作，进入一段时间的等待（进入一个忙循环
）。1.5时默认自旋次数为10次，java1.6引入了自适应自旋锁，会依据上一次自旋获得成功的线程自旋次数，决定要不
要继续自旋。如果自旋一直无法获得成功（或者自旋成功次数太少），之后会跳过这个阶段。

锁消除：虚拟机即时编译器运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。判定
依据：逃逸分析的数据支持，即如果判断在一段代码中，堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以将
其当做栈上的数据对待，认为是线程私有

锁粗化：一系列的连续操作都对同一个对象反复加锁、解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，
频繁地进行互斥同步操作也会导致不必要的性能损耗。当虚拟机探测到有这样一串零碎的操作都对同一对象加锁，将会
把加锁同步的范围扩展到整个操作序列的外部。

轻量级锁：在没有多线程竞争的前提下，较少传统重要级锁操作系统互斥产生的性能消耗（依据：对于绝大部分锁，在整个
同步的周期内都是不存在竞争的）。主要的核心点在于CAS的应用。对象头（Mark Word）里面记录了锁记录的指针以及
状态，如果代码进入同步块的时候，Mark Word里面的锁标志位01，虚拟机首先会在当前线程的栈帧中建立一个叫锁记录
的空间，用于存储锁对象目前的Mark Word拷贝，然后尝试用CAS操作将Mark Word更新为指向锁记录指针，如果更新成功
，代表线程拥有对象锁，将锁标志位置为00，即轻量级状态；更新失败，检查对象的Mark Word是否指向当前线程的栈帧，
如果一致说明当前线程已经获得了对象锁，直接进入同步块执行程序，否则说明对象锁已被其他线程抢占。如果有两条以上
的线程抢占了锁资源，则将锁膨胀为重要级锁（锁状态值为10）

偏向锁：目的是消除数据在无竞争情况的同步原语，以提高程序性能。意思就是在无竞争状态下啥都不做，这个锁会偏向于
第一个获得该锁的线程。如果在接下来的过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要同步（锁状
态值为01）

4. reentrantLock、Synchorized锁对比（synchronized和java.util.concurrent.locks.Lock的异同？）

5. 并行与并发的区别
并行： 在操作系统中，一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的
并发： 在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个
处理机上运行，但任一个时刻点上只有一个程序在处理机上运行

6. 了解线程池，JUC包中的ThreadPoolExeuctor源码阅读

7. java中实现线程安全的三种方式

8. 线程的几个状态，以及状态间的转换

9. Synchorized详解
Synchorized关键字可以对代码块、方法、类进行修饰
Synchorized本质是调用了monitor_enter以及monitor_exit指令来实现加锁

10. java中NIO、BIO、AIO

11. 什么叫线程安全？
当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去
做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类时线程安全的。
简而言之就是在多线程的环境下，程序的结果始终是正确的

12. 为什么代码会重排序？
编译器和处理器为了提高程序的运行性能，对指令进行重新排序。
如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：
| 名称 | 代码示例 | 说明 |
| 写后读 | a = 1;b = a; | 写一个变量之后，再读这个位置。 |
| 写后写 | a = 1;a = 2; | 写一个变量之后，再写这个变量。 |
| 读后写 | a = b;b = 1; | 读一个变量之后，再写这个变量。 |
as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。
编译器，runtime 和处理器都必须遵守 as-if-serial 语义。

并发框架
13. SynchronizedMap和ConcurrentHashMap有什么区别？

14. CopyOnWriteArrayList可以用于什么应用场景？

15. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？

16. java如何实现多线程之间的通讯和协作？

17. 什么场景下可以使用volatile替换synchronized？

18. java中有几种方法可以实现一个线程？
两种方法，一种是可以继承Thread类，或者是实现Runnable接口
