1. 什么是MQ？

2. 使用MQ有什么好处？有什么使用场景？
a) 解耦：
假设系统A分别于系统B、系统C、系统D进行了接口通讯，未来可能还会跟更多的系统进行交互，那么我们就可以称系统A对于整个系统来说耦合程度太高了，
一旦系统A出现了宕机的情况，整个系统都将无法使用。

使用MQ的话，可以将同样的类型的消息放入同一个消息队列，系统A作为消息的发布方，系统C、D等作为消息的订阅方，这样就将系统A从整个系统中解耦出
来了，不需要再去考虑消息的是否到达，消息是否会超时的情况。这里也就涉及到了消息队列的一种模型：Pub/Sub模型

b) 异步：
假设用户发送一个请求，在这个请求里面，系统需要进行一定的响应操作，同时该系统可能需要调用其他的系统进行其他的操作（n步），一旦每一步的操作
时间加长都会给用户带来很不好的体验，更不用加起来的总耗时的情况。

我们可以从用户角度出发，我们只需要呈现出于用户暂时相关的返回结果即可，对于用户不是很关心的内容可以异步操作，最典型的例子就是网站注册的时候
，会需要填写相关信息，同时为了验证你的身份会去进行邮箱激活验证。用户想要的返回结果仅是插入一条记录并告知他注册成功，关于邮件的发送并不需要
即时，也不需要同步，这样就提高了用户的满意度。
c) 削峰：

3. MQ的缺点是什么？

4. 目前市场上比较流行的几种MQ是哪些？各有什么特点？
kafka: 一般都是用来处理日志业务
rocketMQ:
rabbitMQ:
activeMQ:

5. MQ 怎么确保消息被顺序消费？
之所以会提到这个问题，是因为在现在的业务场景中，高并发、多线程已经是常态了。试想一下，如果系统中只存在一个发送方，一个MQ，一个消息的消费者
这个时候就不会存在顺序消费的问题。所以想要顺序消费只要能保证尽量让一个队列去对于一个消费者就可以了。在分析rocketMQ源码的时候，就可以发现他
其实是通过将一个订单号只消费一个MQ，在这个MQ里面我们在发送消息的时候，对于有严格先后顺序的消息肯定可以保证MQ内部的顺序。

6. MQ 怎么确保消息没有被重复消费？
关于重复消费的问题其实转化为如何去保证MQ的幂等性的问题。
方法一：可以通过去维护一个本地消息表，本地的消息执行成功会往本地消息表里面插入一条数据，MQ和本地共同去维护这个本地消息表
方法二：MQ这边标记事务执行成功后，会选择向客户端去发送一个确认的请求，如果请求确认成功，那么MQ也确认成功，如果请求确认失败，MQ回滚事务
方法三：如果换个角度去思考的话，我们发现关于消息是否被重复消费其实完全可以在消费消息的时候进行校验。如果这样一想会发现其实解决问题的方法有
很多种，譬如使用乐观锁+版本号，悲观锁，分布式锁，token的方式以及使用数据库的唯一索引等等方法
