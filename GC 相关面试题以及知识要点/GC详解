#GC一般指的是java堆内存的内存回收

##1. java虚拟机是怎么判断对象是否存活的？
使用的算法是可达性分析算法，即判断该对象与GC ROOTs之间是否存在可达路径，如果不存在则说明该对象需要被回收
PS： 这里需要提及的是，不是被标记是应该被回收的对象之后就会被立马回收，他还有一个自救的机会，在下一次GC 之前如果该
对象被再次引用就不会被回收
python里面使用的引用计数法，但是引用计数法虽然简单，但是效率没有可达性路径分析高，如果存在两个相互引用的对象，这两
个对象

可以作为GC root的对象
a).虚拟机栈中引用的对象（即栈帧中的本地变量表）
b).方法区中的常量引用的对象
c).方法区中的类静态属性引用的对象
d).本地方法栈中的JNI(Native方法)的引用对象
e).活跃线程的引用对象

##2. 垃圾收集算法
a) 标记-清除算法: 缺点标记和清除都很耗时，效率低
b) 复制算法: 不需要考虑内存碎片的复杂情况，只要一动堆顶指针，按顺序分配内存即可，实现简单，运行高效。但是会存在有一部分
内存无法使用（浪费）
c) 标记-整理算法: 主要是针对老年代，标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存
活的对象都向一端移动，然后直接清理掉端边界以外的内存。
d) 分代收集算法: 新生代使用复制算法，老年代使用标记-清除或者标记-整理算法

##3. GC堆是怎么分区分代的？
一般来说堆内存可被分为新生代和老年代，其中新生代包括Eden区、from Survivor区、to Survivor区
新生代中3块区域的比是：8:1:1
默认情况下新生代占据1/3的堆大小，老年代占据2/3的堆大小
JVM每次只会使用Eden区和其中一块Survivor区域来为对象服务，所以无论什么时候，总有一块Survivor区域是空闲的，
因此，新生代实际可用的内存空间为新生代总空间的90%

##4. 垃圾收集器，着重讲G1与CMS垃圾处理器
Serial收集器：最基本、发展历史最久的收集器（单线程）。仅会使用一个CPU或一条收集线程去完成垃圾收集工作，同时其在垃圾收集时，
必须暂停其他所有的工作线程（stop the world）。优点是简单高效。
ParNew收集器：Serial收集器的多线程版本，除了使用多条线程进程垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（如
-XX：SurvivorRatio、-XX:PretenureThreshold等）、收集算法、Stop the world、对象分配规则、回收策略等都与Serial收集器完全一样。
Parallel Scavenge收集器：一个新生代收集器，使用复制算法的收集器，又是并行的多线程收集器。特点在于关注点与其他收集器不同，
CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（
CPU用于运行用户代码的时间与CPU总消耗时间的比值）。 自适应调整策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。
Serial Old 收集器：Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法。
Parallel Old收集器：Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。JDK1.6才开始提供。在注重吞吐量以及
CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。
CMS（Concurrent Mark Sweep）收集器：是一种以获取最短回收停顿时间为目标的收集器。CMS收集器符合系统停顿时间短、服务器响应速度
快的应用需求。基于“标记-清除”算法实现，运行过程分为初始标记、并发标记、重新标记、并发清除。初始标记与重新标记需要
“stop the world”。初始标记仅标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重
新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。停顿时间比初始标记阶段更长，但
是比并发标记时间短。耗时最久的并发标记与并发清除可以与用户线程一起并发执行。
G1收集器：最前沿成果之一，，被视为JDK1.7虚拟机的一个重要进程特征。面向服务端应用的垃圾收集器。特点：并行与并发；分代收集；
空间整合（G1从整体来看是基于标记-整理算法的收集器）；可预测的停顿。G1将java堆划分为多个大小相等的独立区域（Region），
后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。为了避免Region之间的对象引用以及其他收集器中的新生
代与老年代之间的对象引用，虚拟机都是使用remembered Set来避免全堆扫描。
如果不计算维护Remembered Set操作，G1收集器的运作有以下几个步骤：初始标记、并发标记、最终标记、筛选回收

##5. GC发生时如何让所有线程（不包括JNI调用的线程）都跑到最近安全点停顿下来？
a).	抢先式中断：不需要线程的执行代码主动配合，GC发生，先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让
他跑到安全点（不使用）
b).	主动式中断：GC发生不直接对线程操作，仅简单设置一个标志，各个线程执行时主动去轮询标志，发现中断标志为真就自己中断挂起。

##6. 对象的年龄怎么计算？
正常情况是对象每熬过一次Minor GC，对象的年龄会加1；
如果该年龄段所有对象所占空间和大于survivor空间的一般，则直接该对象直接进入老年代。

##7. 从jvm的角度讲对象在堆上的内存分配？
新分配出来的对象，首先会将其分配在Eden区，如果Eden区放不下这个对象，就会触发一次Minor GC，如果Minor GC之后能够存活，且能被
Survivor空间接收，那么该对象会被移动到survivor空间中，并把对象的年龄加一。对象在Survivor中每熬过一次Minor GC，年龄加一，当
年龄达到一定程度就会被晋升到老年代；如果对象的大小过大新生代无法容纳，对象大小大于-XX:PretenureSizeThreshold值，会绕过新生代
直接在老年代分配。

##8. 空间担保机制
在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，这个条件成立，Minor GC可以确保是安全的。
如果不成立，虚拟机会查看是否允许担保失败，如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，
如果大于将尝试进行一次Minor GC，如果小于，或者设置不允许冒险，那么这时要改为进行一次Full GC（JDK 6 Update24之后冒险设置参数无效
，其中规定只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC）
